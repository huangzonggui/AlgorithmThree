//定义于字母表∑{a,b,c)上的乘法表如表1所示
//	表1∑乘法表
//	   a  b  c
//	a  b  b  a
//	b  c  b  a
//	c  a  c  c
//
//	依此乘法表,对任一定义于∑上的字符串,适当加括号表达式后得到一个表达式。例如,对于字符串x=bbbba,它的一个加括号表达式为i(b(bb))(ba)。
//	依乘法表,该表达式的值为a。试设计一个动态规划算法,对任一定义于∑上的字符串x=x1x2…xn，计算有多少种不同的加括号方式,
//	使由x导出的加括号表达式的值为a
//	要求：
//	输入：输入一个以a,b,c组成的任意一个字符串。
//	输出：计算出的加括号方式数，使由x导出的加括号表达式的值为a。
//
//	思路：
//
//	建立一个三位数组，用于记录一段连续的序列内通过加括号可得到a、b、c的方式数，然后往长度方向扩展，因为每两个字母相乘的结果已给出，
//	所以可通过加和乘运算求出更大长度的字符串得到a、b、c的方式数
//
//
//	具体算法：
//数组维数为:p[n][n][3];
//p[i][j][k] 表示 字符串xix(i+1)....xj的表达式的值为k(k>=0 k <=2,k=0表示a...) 的方式数；
//
//	递推式为：
//	p[i][j][0]=   sum(p[i][t][0]*p[t+1][j][2]+p[i][t][1]*p[t+1][j][2]+p[i][t][2]*p[t+1][j][0]) 
//	p[i][j][1]与p[i][j][2]类似p[i][j][0] 的求法 t>=i 并且t <j

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
using namespace std;
int main(){
	int n=0;//字母个数
	cout<<"在字母表∑={a,b,c}上定义乘法运算：\n";
	cout<<"   a  b  c \n";
	cout<<"a  b  b  a \n";
	cout<<"b  c  b  a \n";
	cout<<"c  a  c  c \n";
	cout<<"请输入abc字母串： \n";
	char ch;
	int p[100][100][3]={0};
	while ((ch=getchar())!='\n')
	{
		//其实就是标记abc
		p[n][n][ch-'a']=1;//ch-'a'是通过ASCII码求得  p[1][1][0]=1表示第i个字母为a，加括号数为1，i!=j初值为0,在下面的循环里赋值
		n++;
	}
	//k代表ij之间的间隔，例如：k=1时，那么循环做的是从0到1，从1到2，从2到3......
	//						   k=2时，那么循环做的是从0到2，从1到3，从3到5......
	//这样就可以将所有可能的循环完
	for (int k=1;k<n;k++)
	{
		for (int i=0;i<n-k;i++)
		{
			int j=i+k;//控制j<n
			for(int t=i;t<j;t++)
			{
				//a+=1表示a=a+1
				p[i][j][0] += p[i][t][2]*p[t+1][j][0] + p[i][t][0]*p[t+1][j][2] + p[i][t][1]*p[t+1][j][2];//值是a=a+c*a+a*c+b*c
				p[i][j][1] += p[i][t][0]*p[t+1][j][0] + p[i][t][0]*p[t+1][j][1] + p[i][t][1]*p[t+1][j][1];//值是b=b+a*a+a*b+b*b
				p[i][j][2] += p[i][t][1]*p[t+1][j][0] + p[i][t][2]*p[t+1][j][1] + p[i][t][2]*p[t+1][j][2];//值是c=c+b*a+c*b+c*c
			}
		}
	}
	cout<<"加括号表达式的值为a加括号总方式数：\n";
	printf("%d\n",p[0][n-1][0]);
	cout<<"加括号表达式的值为a加括号方式数矩阵（p[i][j][0]）：\n";
	for (int i=0;i<n;i++)
	{
		for (int j=0;j<n;j++)
		{
			printf("%d  ",p[i][j][0]);
		}
		printf("\n");
	}
	system("PAUSE");
}